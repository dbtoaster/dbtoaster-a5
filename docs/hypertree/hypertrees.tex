\documentclass[12pt]{article}
\usepackage{tikz}
\usetikzlibrary{shapes,snakes}
\usepackage{algorithm}
\usepackage{algorithmic}%\usepackage[pagebackref=true,colorlinks,linkcolor=blue,citecolor=magenta]{hyperref}
\usepackage{graphicx} 
\usepackage{fancybox}
\usepackage{setspace}  
\usepackage[colorlinks,linkcolor=blue,citecolor=magenta]{hyperref}
\usepackage{enumerate} 
\usepackage{amsthm,amssymb,amsmath}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{fullpage}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\usetikzlibrary{fit}
\renewcommand{\algorithmiccomment}[1]{// #1}
\begin{document}

\title{Draft of Hypertree Decomposition}
\date{\today}
\maketitle
\section{Introduction}
In this draft we talk about the hypertree decomposition and the advantage of using it for delta queries computations. The main contribution of this paper is that it proves that the total number of nodes in all hypertree decomposition of all delta queries is polynomial and we give an algorithm for computing the delta trees.
\section{Preliminaries}
Throughout this paper, for the sake of simplicity, we are dealing only with Boolean Conjunctive Queries (BCQ). These results can be extended to other queries as well. Suppose we are given a query and we want to evaluate it. This is called \emph{evaluation problem} and is an NP-complete problem\cite{1}. Thus, generally it is not solvable with a polynomial time algorithm, but in some restricted versions we can solve this problem in polynomial time. \par

One important class for which we have polynomial algorithms is \emph{Acyclic Queries} \cite{1}. 

We use $var(Q)$ to show the set of variables in query $Q$ and $relations(Q)$ denotes the set of relations in query $Q$.
\begin{definition}
\label{def:hypergraph} 
The hypergraph of query $Q$ is a hypergraph $G(V,E)$ where $V=var(Q)$ and for each relation $A$ we add an hyperedge among all $var(A)$.
\end{definition}
\begin{definition}
\label{def:primalgraph}
The primal graph of query $Q$ is a graph $G(V,E)$. where $V=vars(Q)$ and for all relations $A$ and for all $a,b\in vars(A)$ we add an edge between $a$ and $b$, $E=\{(a,b)|\exists A: a\in vars(A)\land b\in vars(A)\}$
\end{definition}
If the primal graph of a query is acyclic, we can call it the \emph{Join Tree}\cite{1}. As previously stated, we can evaluate a query in polynomial time when we have its join tree. Although we rarely encounter acyclic queries, in many cases we can decompose the primal graph into a tree. For example we can use a tree decomposition algorithm on the primal graph to obtain a tree. After decomposing the query, some nodes will have more than one relation, thus, the maximum number of relations in any node is called \emph{treewidth}. 
Finding the treewidth of a graph is an NP-complete problem\cite{treewidth}. Thus we can not decompose a graph into a tree with the minimum possible treewidth in a polynomial time unless P=NP, but, if we know in advance that the treewidth is fixed, we can decompose the graph in a polynomial time. 
%Bounded treewidth is very common for queries, we can guess an upper bound on the treewidth and then compute the tree decomposition. 
\begin{definition}
\label{def:dualgraph}
The dual graph of query $Q$ is a graph $G(V,E)$. where $V=relations(Q)$ and for each relation $A$ for which we have $var(A)\cap var(B)\neq \emptyset$, we add an edge between $A$ and $B$. $E=\{(a,b)|var(a)\cap var(b)\neq\emptyset\}$
\end{definition}
%The definition of dual graphs~\eqref{def:dualgraph} came from the dual of hypergraph. 
\subsection{Generalization for inequalities and nested queries}
\label{sec:generalization}
In the previous section we have presented the notions of graph and hypergraph models for queries which only contain equaljoins. In those models we cannot have any inequalities or any nested queries. But in this section we want to generalize those models for these two case. We consider each inequality as an imaginary relation between two variables. Imaginary here means that we do not need to materialize it. Thus, in the hypergraph representation each inequality $a\theta b$ is a hyperedge on $a$ and $b$. In dual graph modelling it is a vertex which is connected to other vertices which have the same variables as the inequality's operator.\\\par

For the nested queries, we can also consider them as an imaginary relation. A subquery is an assignment. Let us suppose that we have a subquery $t\gets q$ where $q$ represents the subquery's body and $t$ is the name of the variable which is given to it for the representation. This is the same as the alpha5 notation in DBToaster\cite{1}. The imaginary relation for the nested query contains $t$ and all the participating variables in the body of $q$. In this way we preserve the meanings of these variables, they are related to each other like an ordinary relation. Thus, in hypergraph model we have a hyperedge for the subquery and in the dual model we have a vertex for it. We use $R\in t$ to denote whether or not $R$ has appeared on the right hand side of assignment operator for $t$. \\\par
When talking about inequalities, the hyperedge between the variables that constitiute the inequality is a simple edge like in a normal graph. When having $a\theta b$ we can replace it with $F(\theta,a,b)$, where $F$ is a imaginary relation. 

For example, we have the following query:
$$\mbox{SELECT SUM(1) FROM R(a,b),S(c,d) WHERE R.b$>$S.c}$$
This query can easily be modified:
\begin{align*}
\mbox{SELECT SUM(1) FROM R(a,b),S(c,d),F($>$,b,c)}\\\mbox{WHERE R.b=F.b AND S.c=F.c}
\end{align*}

This is also true for assignments, or in other words for nested queries. We know that $t\gets q[\vec{x}][\vec{y}]$ can be transformed, as for inequalities, into a relation between the variables:$F(\gets,t,{\vec{x}|\vec{y}}_{\mbox{from main query}},{\vec{x}|\vec{y}}_{\mbox{from subquery}})$, where ${\vec{x}|\vec{y}}_{\mbox{from main query}}$ will represent the list of variables from the main query which will influence the subquery by the list of variables from the subquery $ {\vec{x}|\vec{y}}_{\mbox{from subquery}}$

\section{Hypertrees}
Although the treewidth is a useful concept, we have a better concept as the hypertree width. The notion of hypertree and hypertree width for the first time introduced in \cite{1}. For example consider the following query: $q\gets p_{1}(X_{1},\cdots X_{n})\land\cdots\land p_{m}(X_{1},\cdots,X_{n})$, this query can be answered in the polynomial time, but its treewidth is $n-1$. So for some simple queries we may have unbounded treewidths. To overcome such these problems, we need a more powerful concept for the decomposition.
In this section we define two concepts of hypertree and hypertree decomposition. 
These two definitions are taken from \cite{1}.
\begin{definition}
\label{def:ht}
Let $Q$ be a conjunctive query. A Hypertree for $Q$ is a triple $\textless T,\chi,\lambda\textgreater$, where  $T=(N,E)$ is rooted tree and $\chi$ and $\lambda$ are labeling function which associate to each vertex of $p\in T$ two sets $\chi(p)\subseteq var(Q)$ and $\lambda(p)\subseteq relations(Q)$.
\end{definition}
If $T'=(N',E')$ is a subtree of $T$, we define $\chi(T')=\cup_{v\in N'}\chi(v)$. We denote the set of vertices $N$ of $T$ by $vertices(T)$ and the root of $T$ by $root(T)$. Moreover, for any $p\in N$, $T_{p}$ denotes the subtree of $T$ rooted at $p$.
\begin{definition}
\label{def:htd}
A hypertree decomposition of a conjunctive query $Q$ is a hypertree $\textless T,\chi,\lambda\textgreater)$ wich satisfies all the following conditions:
\begin{enumerate}
\item for each relation $A\in relations(Q)$, there exists $p\in vertices(T)$ such that $var(A)\subseteq \chi$;
\item for each variable $Y\in var(Q)$ the set $\{p\in vertices(T)|Y\in\chi(p)\}$ induces a connected subtree of $T$;\label{connectedness}
\item for each vertex $p\in vertices(T)$, $\chi(p)\subseteq var(\lambda(p))$;
\item for each vertex $p\in vertices(T)$, $var(\lambda(p))\cap(T_{p})\subseteq \chi(p)$
\end{enumerate}
\end{definition}
The width of the hypertree decomposition $\textless T,\chi,\lambda\textgreater$ is $\max_{p\in vertices(T)}|\lambda(p)|$. The hypertree-width $hw(Q)$ of $Q$ is the minimum width over all its hypertree decompositions.\par
Let us fix a given query  as $Q$. Suppose for $Q$  we have its hypertree decomposition $HT_{Q}$. 
%Condition \ref{connectedness} is called the connectedness property. 
%With aforementioned generalizations for inequalities and nested queries, the connectedness property does not hold anymore, fortunately none of our results depends on it. 
The most important property of hypertree is that we can compute the query according to its structure in polynomial time. In fact the order of evaluating $Q$ in hypertree $HT$ is $O((||Q||+||HT||)r^{k})$ \cite{1}. $||Q||$ denotes the size of $Q$ and $||HT||$ is the size of its hypertree decomposition, $r$ is the maximum relation size over the relations in the database and $k$ is the hypertree width. \par

For example for query $Q'$ we have:
\begin{align}
\label{q'}
Q': &a(S,X,X',C,F)\land b(S,Y,Y',C',F')\land c(C,C',Z)\land d(X,Z)\land e(Y,Z)\nonumber\\
&\land f(F,F',Z')\land g(X',Z')\land h(Y',Z')\land j(J,X,Y,X',Y')
\end{align}

\usetikzlibrary{positioning,shadows,arrows}
\begin{figure}[htbp]
\begin{center}
\usetikzlibrary{fit}
\begin{tikzpicture}%[level/.style={sibling distance=40mm,level distance=15mm}]
[level 1/.style={scale=1.0, fill=red,
    level distance=28pt, sibling distance=150pt},
    level 2/.style={ scale=1.0,
    level distance=30pt, sibling distance=200pt},
    level 3/.style={ scale=0.7,
    level distance=60pt, sibling distance=150pt}]
    level 4/.style={ scale=0.7,
    level distance=60pt, sibling distance=150pt}]  
    \tikzstyle{every node}=[rectangle,draw,fill=red!20]
    \node [rectangle,draw,fill=red!20]{$v_{1}:\{J,X,Y,X',Y'\},\{j\}$}
        child { 
            	node[rectangle,draw,fill=red!20] {$v_{2}:\{X,X',Y,Y',S,C,C',F,F'\},\{a,b\}$}
        		child { 
        			node[rectangle,draw,fill=red!20] {$v_{3}:\{X,Y,C,C',Z\},\{j,c\}$}
			child{
				node[rectangle,draw,fill=red!20] {$v_{4}:\{X,Z\},\{d\}$}
			}
			child{
				node[rectangle,draw,fill=red!20] {$v_{5}:\{Y,Z\},\{e\}$}
			}
		}
		child{
      			node[rectangle,draw,fill=red!20] {$v_{6}:\{X',Y',F,F',Z'\},\{j,f\}$}
			child{
				node[rectangle,draw,fill=red!20] {$v_{7}:\{X',Z'\},\{g\}$}
			}
			child{
				node[rectangle,draw,fill=red!20] {$v_{8}:\{Y',Z'\},\{h\}$}
			}
		}
	}
    ;
\end{tikzpicture}
\end{center}
\caption{An example of a hypertree decomposition of the query $Q'$ given as \eqref{q'}, nodes are labeled by $v_{1}\cdots,v_{8}$}
\label{fig:hypertree}
\end{figure}
A hypertree of query $Q'$ is  shown in Figure~\ref{fig:hypertree}. The hypertree width is 2 in this case. 
\subsection{Unions and Hypertrees}
\label{sec:unionsand}
The hypertree model is basically useful for representing only equal joins. In section \ref{sec:generalization} we extended it for inequalities and nested query. In order to represent any AGCA expressions(i.e. SQL expressions) with this model, we need to represents unions also. \par
One naive idea for representing the query is to distribute joins over unions. For example if we have $(R+S)\Join T$ we can rewrite it as $R\Join T+S\Join T$. But this method may result in exponential number of terms. As converting any CNF formula to DNF formula may produce exponential number of terms. For example for $(S_{1}+R_{1})\Join\cdots\Join(S_{n}+R_{n})$ we need exactly $2^{n}$ different union terms, although the original query had $n$ terms. 
This method can be useful if we have a limited number of unions. \\\par
Another method is to use the parse tree of the query. First we have to parse the input query as DBToaster does it, and then remove the union nodes. Each connected component is a part of the given query and for it we can compute its hypertree representation. These hypertrees are connected together by the union nodes. In this way the hypertree width of the whole query is not increased, it can be proved  by induction on the depth of parse tree. At any union node we have two children. Each of them has its own hypertree width. The hypertree width of the union node is the maximum of these two hypertree width. Thus, the hypertree width of the whole parse tree is the maximum of the hypertree width of all connected component.


%There is another theorem like Theorem~\ref{thm:1} but for the structure of all possible trees.
%\begin{theorem}
%\label{thm:2}
%The number of different structures of all these trees are polynomial for a constant hypertree width.
%\end{theorem}
%\begin{proof}
%If $\Delta_{\pm R}$ applies to a join tree it won't change the nodes that do not contain relation $R$. Thus, without loss of generality we can assume that $R$ has appeared in all nodes  for the worst case(i.e. Figure~\ref{fig2}). \par
%
%When we apply $\Delta_{\pm R}$ to a tree, each node splits into 3 different nodes($\Delta(R\Join S)=\Delta(R)\Join S+R\Join\Delta(S)+\Delta(R)\Join\Delta(S)$) \cite{2}. In the worst case, for each node at most 3 new nodes is created, thus, the number of nodes remains linear in term of the number of original nodes in the hypertree. \par
%We can say the same thing for the cost of evaluation of the hypertrees. 
%If we consider each $+,\Join$ as one operation, evaluation of $\Delta(R\Join S)$ needs at most 5 operations. Thus, the cost of evaluation of all $\Delta$ trees is $O(n)\times(\text{Cost of join operator})$.
%\begin{figure}[htbp]
%\begin{center}
%\begin{tikzpicture}%[level/.style={sibling distance=40mm,level distance=15mm}]
%[
%    %
%    level 1/.style={rectangle, draw,scale=1.0, fill=red,
%    level distance=30pt, sibling distance=130pt},
%    level 2/.style={rectangle, draw, scale=1.0,
%    level distance=50pt, sibling distance=70pt}]
%    \tikzstyle{every node}=[rectangle,draw,fill=red!20]
%    \node {$\cdots R\bowtie \cdots$}
%        child { 
%            node {$\cdots R\bowtie \cdots$}
%        }
%        child { 
%        		node {$\cdots R\bowtie \cdots$}
%		child{
%       		node {$\cdots R\bowtie \cdots$}
%		}
%		child{
%       		node {$\cdots R\bowtie \cdots$}
%		}		
%	}
%    ;
%\end{tikzpicture}
%\end{center}
%\caption{A worst case tree for Theorem~\ref{thm:2}}
%\label{fig2}
%\end{figure}
%\end{proof}
\section{Application of Hypertree Decomposition in DBToaster}
Gottlob et al. have shown that for each Hypertree there exists a join tree with the same tree structure(Lemma 4.6)\cite{1}. Thus, we have these results for join trees too. The advantage of hyperrtrees over the join trees is that the hypertree width is always less than or equal to the treewidth. %Also, acyclic queries may have unbounded treewidth\cite{1}.\\\par

We can compute the hypertree decomposition in several ways. Each definitions of dual graph, hypergraph and primal graph will result into a decomposition.
\par
If we want to find a hypertree decomposition using the dual graph, for each node we need to select some relations for joining together. The act of selecting the relations is contracting some nodes in the corresponding dual graph. 
For hypergraph model we can do the same process, but here we select a set of vertices which are the variables and contract them together.\par

In AGCA(which is stands for AGgregation CAlculus)\cite{2} \emph{delta queries} are introduced for incremental view maintenance. 
Let $u$ denote a change(an insertion or deletion) to database $D$. Applying $u$ to the database $D$ is shown by $D+u$. Here ``+'' denotes a function which applies $u$ into $D$. Let us fix a query $Q$. A delta query $\Delta Q$ expresses the change to the result of query $Q$ as database $D$ is updated to $D+u$.  This modification can also be represented as a query which is shown by $\Delta_{\pm R}(Q)$. Here $\pm R$ shows an insertion or a deletion to/from $R$, but for our purpose we treat both of them as the same thing.

We can continue the same thing  for query $\Delta_{\pm R}(Q)$. For example $\Delta_{\pm S}(\Delta_{\pm R}(Q))$ is the delta with respect to $\pm S$ of delta with respect to $\pm R$ of $Q$. We use notation $\Delta_{\pm S\pm R}(Q)$ for showing it also. Applying $\Delta$ has several properties: 
\begin{enumerate}
\item The order of applying $\Delta$ is not important, i.e. $\Delta_{+R-S}(Q)=\Delta_{-S+R}(Q)$, since  ``+'' is a commutative operation in the ring of databases \cite{2}.
\label{delta1}
\item $\Delta_{+R-R}(Q)=Q$, since $-R$ is the inverse of $R$.
\item If there is no self join, with applying $\Delta_{\pm R}$ relation $R$ is eliminated from the set of relations in query $\Delta_{\pm R}(Q)$. Thus, if at the beginning we had $n$ relations after applying any delta we would have $n-1$ relations.
\item For simple queries(i.e. queries which do not have any self joins) $\Delta_{+R+R}(Q)$ or $\Delta_{-R-R}(Q)$ is NULL, as the consequence of the previous property. 
\end{enumerate}
We call $\Delta_{\pm R_{i}\cdots\pm R_{j}}$ a sequence of delta. 
In \cite{2} it is shown that every query $Q$ has some sequences of delta $\Delta_{\pm R_{i_{1}}\cdots\pm R_{i_{k}}}$ which $\Delta_{\pm R_{i_{1}}\cdots\pm R_{i_{k}}}(Q)$ is NULL.
According to these properties, when there is no self join, a query with $n$ different relations has at most $n!\times 2^{n}$ different sequences of delta. \\\par
In subsection \ref{sec:algorithmdelta} we introduce an algorithms for computing the $\Delta_{\pm R}(Q)$ for a given hypertree decomposition of $Q$. In subsection~\ref{sec:theorem1} we prove that if we use this algorithm for computing all possible sequences of delta, the runtime is polynomial in term of the number of relations. 
\subsection{Algorithms for $\Delta$ queries}
\label{sec:algorithmdelta}
In this section we present an algorithm for computing  $\Delta$ of the hypertree of a query with respect to a relation. We abuse the notation $\Delta_{\pm R}(Q)$ for the delta of a hypertree decomposition of query $Q$. We show it by $\Delta_{\pm R}{HT_{Q}}$.\par 
%As we had in Theorem~\ref{thm:2} for 
For computing $\Delta_{\pm R}{HT_{Q}}$, the worst case is when every node contains relation $R$ (i.e. \ref{fig3}) or has a variable which represents a subquery that contains $R$.
\begin{figure}[htbp]
\begin{center}
\usetikzlibrary{fit}
\begin{tikzpicture}%[level/.style={sibling distance=40mm,level distance=15mm}]
[
    %
    level 1/.style={scale=1.0, fill=red,
    level distance=30pt, sibling distance=150pt},
    level 2/.style={ scale=1.0,
    level distance=30pt, sibling distance=70pt},
    level 3/.style={ scale=0.7,
    level distance=60pt, sibling distance=120pt}]
    
%    \tikzstyle{every node}=[rectangle,draw,fill=red!20]
    \node [rectangle,draw,fill=red!20]{$\cdots R\Join \cdots$}
        child { 
            node[rectangle,draw,fill=red!20] {$\cdots R\Join \cdots$}
        }
        child { 
        		node[rectangle,draw,fill=red!20] {$\cdots R\Join \cdots$}
		child{
       		node[rectangle,draw,fill=red!20] {$\cdots R\Join \cdots$}
		}
		child{
       		node[rectangle,draw,fill=red!20] {$\cdots R\Join \cdots$}
		child{
			node(b) [rectangle,draw,fill=red!20]{$\cdots R\Join \cdots$}
		}
%		child{
%			node{$\cdots$}
%		}
		child{
			node (a) [rectangle,draw,fill=red!20]{$\cdots R\Join \cdots$}
		}
		}		
	}
    ;
    \draw[dotted] (a) -- (b);
    \node(ff)[draw=blue,inner sep=0pt,thick,ellipse,fit=(a) (b)] {};
    \node[below=3mm of ff ] {j elements};
\end{tikzpicture}
\end{center}
\caption{Computing the $\Delta_{\pm R}$}
\label{fig3}
\end{figure}

\begin{algorithm}[H]
\caption{Computing $\Delta_{\pm R}(v)$} 
\label{alg1}
\textbf{Input:} node $v$ as the root of $HT_{Q}$ and relation $R$ as the $\Delta$ variable.\\
\textbf{Output:} Calculus expression for $\Delta_{R}$ for node $v$
\begin{algorithmic}[1]
\STATE Compute the delta of expresion containing in $v$
\STATE $J\gets v$ 
\FORALL{Child $i$ of node $v$}
\IF{ $T_{i}$ has any node labeled by $R$ or a $t$ for which $R\in t$}
\STATE Compute $\Delta_{\pm R}(i)$% Computes the $\Delta_{R}$ of $i$ recursively and store it in $\Delta[i]$ if it is not already computed.
\STATE $J\gets J\cup\{i\}$%add $i$ to $J$
\ENDIF
\ENDFOR
%\STATE $Exp\gets\emptyset$
\STATE $value\gets ComputeChain(J)$
\RETURN $value.expr$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{ComputeChain$(J)$} 
\label{alg2}
\textbf{Input:} A set of sibling nodes of $HT_{Q}$ as $J$ and relation $R$ as the $\Delta$ variable.\\
\textbf{Output:} Calculus expression for $\Delta_{R}$ for input nodes\\
\begin{algorithmic}[1]
\IF{$|J|=1$}
\STATE $expr\gets \Delta_{R}(J_{1})$ \COMMENT{$J_{1}$ is the first element of $J$}
\STATE $join\gets J_{1}$
\ELSE
\STATE $rest\gets ComputeChain(J\setminus J_{1})$
\STATE $join\gets J_{1}\Join rest.join$
\STATE $expr\gets rest.expr\Join \Delta(J_{1})+\Delta(J_{1})\Join rest.join+J_{1}\Join rest.expr$ \label{line:joinrule}
\ENDIF
\RETURN $(exp,join)$
\end{algorithmic}
\end{algorithm}
Algorithm~\ref{alg1} computes the $\Delta_{\pm R}$ of any hypertree. At each node $v$ we check if the subtree rooted at $v$ contains any node with label $R$ or any variables as a subquery which the subquery contains $R$. In either of these two cases we compute the $\Delta_{\pm R}$ of the subtree, otherwise its $\Delta_{\pm R}$ is zero. \\
The computation is straightforward. For computing the delta of each node $v$, we first compute the delta of its children recursively  and then $v$ itself. This is done in Algorithm~\ref{alg1}. 
\par
The algorithm needs to compute the delta of each node just one time. If we want to compute the delta of a node with branching factor $k$ it needs $2^{k}-1$ different joint operation($\Join$) which is exponential in the worst case. But we can use a simple trick here. For the node we can first consider $\Delta_{\pm R}$ of $k-1$ children and store it somewhere then with this value we can merge the $k$th one. With Algorithm~\ref{alg2} we can compute the $\Delta_{\pm R}$ in $O(n)$.\par
As an example, suppose we want to compute the delta of hypertree given in Figure~\ref{fig:hypertree} with respect to $j$. Let us call the hypertree as $HT$. We call Algorithm~\ref{alg1} for the root node which is $v_{1}$. First we compute the delta of $v_{1}$, itself, and then we call the algorithm on $v_{2}$, since $T_{v_{2}}$ contains $j$. The delta of $v_{2}$ is 0 since it does not contain relation $j$. Then we recursively compute the deltas for $v_{3}$ and $v_{6}$. Having $\Delta_{\pm j}(v_{3}), \Delta_{\pm j}(v_{6})$ and $\Delta_{\pm j}(v_{2})$ we can compute $\Delta_{\pm j}(T_{v_{2}})$ by the rules which is given in \cite{2} and is implemented in line~\ref{line:joinrule} of algorithm~\ref{alg2}.
\subsection{Number of different nodes or trees is polynomial}
\label{sec:theorem1}
In this section we suppose that a hypretree decomposition for a query is given as $HT_{Q}$. We can apply Algorithm~\ref{alg1} to $HT_{Q}$ and obtain a parse tree. Here we say a parse tree instead of a hypertree because the structure which we obtain as the output of Algorithm~\ref{alg1} contains unions. With what we have explained in section~\ref{sec:unionsand} we can eliminate unions, thus without loss of generality we can consider that the output of the algorithm is a set of hypertrees. For each sequence of delta if applies on a hypertree we have a set of hypertrees(Since we split the nodes on unions). What we are interested is the total number of nodes in all hypertrees which are created by consecutive execution of Algorithm~\ref{alg1}.  
\begin{theorem}
\label{thm:1}
The number of all nodes in all possible hypertrees is polynomial in terms of the number of relation, for any given hypertree decomposition if the hypertree width is fixed. 
\end{theorem}
\begin{proof}
Let $k$ to be the hypertree width of the given hypertree decomposition of query $Q$ ($HT_{Q}$). Here we consider the case when $k$ is fixed (we have an upper bound for it).

Each node of $HT_{Q}$ contains at most $k$ different relations joining together. In other words, without loss of generality, each node is of form $R_{i_{1}}\Join\cdots\Join R_{i_{m}}$ which $m\leq k$. Lets fix one particular node as $l$ with $m$ relations and the set of its indices is $I$. If we apply $\Delta_{\pm R_{i_{p}}}$ if $i_{p}\not\in I$ then this node will be $\emptyset$. For the other case we will have node $R_{i_{1}}\Join\cdots R_{i_{p-1}}\Join R_{i_{p+1}}\cdots R_{i_{m}}$, in other words relation $R_{i_{p}}$ is deleted from node $l$.\\
Thus, for counting the number of all nodes in all hypertrees for all sequences of delta, we should count all nodes which contain $1,2,\cdots,k$ different relations. This number is 
\begin{equation}
\sum_{i=1}^{k}{\binom{n}{i}}<(n+1)^{k}
\end{equation}
which is polynomial for a fixed $k$, since all of these hypertrees may contain some nodes up to $k$ different relations. 

\end{proof}

\section{Nested queries}

In this section we are going to talk about nested queries and how the algorithm for computing the delta queries will be applied to such queries. 

For example if we have the following query:

\begin{align}
\label{query:nest}
&\mbox{SELECT COUNT(*) }\\
&\mbox{FROM R}\nonumber\\
&\mbox{WHERE R.a}<\mbox{(SELECT sum(c) FROM S WHERE R.b=S.b)}\nonumber
\end{align}

Query \ref{query:nest} is a nested query because all of its records are influenced by the result offered by the inside query. When transforming the query into DBToaster Calculus we are going to have the following expression:
\begin{align}
\sum(R\cdot(R.a<\sum[(S.b=R.b)\cdot S.c]))
\end{align}
However this expression can be modified so that inequalities will appear only between variables, and therefore introduce an assignment operator ``$\gets$'':
\begin{align}
\label{form}\sum(R\cdot(t\gets\sum[(S.b=R.b)\cdot S.c])\cdot(R.a<t))
\end{align}

Considering the representation of a hypergraph, we can represent the connections between the variables of the previous example. In a hypergraph the vertices are the variables and the edges represent the relations between these vertices. Taking into account the previous example we have the following types:
\begin{enumerate}
\item relation R: which has the variables $a$ and $b$
\item the inequality $\theta$: which connects variable $a$ with variable $t$
\item the assignment $\gets$: which connects variable $t$ with variable $b$, because $t\gets q_{1}$ with bound variable $b$
\end{enumerate}
\begin{align}
\label{hyper}
\setlength{\unitlength}{1mm}
\begin{picture}(50,50)
\put(50,30){\line(-3,2){30}}
\put(20,50){\line(-1,-4){10}}
\put(10,10){\line(2,1){40}}
\qbezier(50,30)(10,10)(20,50)
\put(50,30){$a$}
\put(20,50){$t$}
\put(8,8){$b$}
\put(30,15){$R$}
\put(37,40){$\theta$}
\put(10,30){$\gets$}
\put(24,27){\mbox{cut line}}
\end{picture}
\end{align}

Figure \ref{hyper} represents a hype graph representation of the connections between the variables that appear in the formulae \ref{form}. We make a cut through the hypergraph along the variables $a$ and $t$. After this cut we can construct a tree which resembles a parse tree.

\begin{figure}[htbp]
\begin{center}
\usetikzlibrary{fit}
\begin{tikzpicture}%[level/.style={sibling distance=40mm,level distance=15mm}]
[
    %
    level 1/.style={scale=1.0, fill=red,
    level distance=30pt, sibling distance=150pt},
    level 2/.style={ scale=1.0,
    level distance=30pt, sibling distance=90pt},
    level 3/.style={ scale=0.7,
    level distance=60pt, sibling distance=120pt}] 
    \tikzstyle{every node}=[rectangle,draw,fill=red!20]
    \node [rectangle,draw,fill=red!20]{$a,t$}
        child { 
            	node[rectangle,draw,fill=red!20] {$a,t,b$}
        		child { 
        			node[rectangle,draw,fill=red!20] {$a,b\coloneqq R$}
				}
				child{
      				node[rectangle,draw,fill=red!20] {$t,b\coloneqq t\gets m_q[][b]$}
				}
	}
	child {
	node[rectangle,draw,fill=red!20] {$a,t\coloneqq\theta$}
	}
    ;
\end{tikzpicture}
\end{center}
\caption{A decomposition of the query \ref{form}}
\label{figtree}
\end{figure}
As you can see the decomposition of the example query is a parse tree, which will have as leaves the connections between the variables of the query. When talking about variables $t$ and $b$, these variables participate in the assignment of the value of the subquery to the variable $t$. The result offered by the subquery will be influenced by the value of $b$ from relation $R$. Therefore we can substitute the subquery with a data structure which keeps the values for each different $b$: we substitute it with a map, which is a function defined on the domain of variable $b$ and which offers results for each value of $b: m_q[][b]\coloneqq\sum[(S.b=R.b)\cdot S.c]$.

The subquery can also be further down decomposed:
\begin{align}
\label{hyper1}
\setlength{\unitlength}{1mm}
\begin{picture}(50,50)
\put(40,20){\line(-3,2){30}}
\put(40,20){$b$}
\put(10,40){$c$}
\put(27,30){$S$}
\end{picture}
\end{align}
In the hypergraph \ref{hyper1} we have just a simple relation. However in a more general case the sub queries can be more complicated. Another method of obtaining a decomposition of a query is by using the dual graph of the hypertree. We know that a dual graph will be graph which has as vertices the relations and as edges the variables that make the connection between those relations. Going back to the example~\ref{query:nest}, we can represent that query as follows:

\begin{align}
\label{hyper3}
\setlength{\unitlength}{1mm}
\begin{picture}(50,50)
\put(50,30){\line(-3,2){30}}
\put(20,50){\line(-1,-4){10}}
\put(10,10){\line(2,1){40}}
\put(10,10){\line(5,0){14}}
\put(50,30){$R$}
\put(20,50){$\theta$}
\put(8,8){$\gets$}
\put(25,8){$S$}
\put(30,15){$b$}
\put(37,40){$a$}
\put(10,30){$t$}
\put(18,10){$b$}
\end{picture}
\end{align}

We have treated the inequality as a relation and therefore put it on the dual graph representation as a vertex, as well for the assignment operator. However the vertex representing the assignment operator is connected with relation $R$ and relation $S$ through the variable $b$. The variable $b$ from relation $R$ influences the result of the subquery, because of the $equal$ between relation $R$ and $S$: $R.b=S.b$.

Having this representation we can make cuts through relations and therefore we can obtain a tree decomposition of the query. Each node of the tree is represented by relations and the edges are the connections between relations that are mapped to different nodes.

Having this example and the extensions of hyperedges in section \ref{sec:generalization}, we can say that the ideas for performing the tree decomposition, even when having inequalities and assignments, will work in the general case. 

\begin{thebibliography}{9}
\bibitem{2} C. Koch, \emph{Incremental Query Evaluation in a Ring of Databases},  preprint (2011).
%\bibitem{3} O. Kennedy, Y. Ahmad, C. Koch. \emph{DBToaster: Agile views for a dynamic data management system}. In CIDR, 2011.
\bibitem{1} Georg Gottlob, Nicola Leone and Francesco Scarcello, \emph{Hypertree Decompositions and Tractable Queries} J. Comput. Syst. Sci., 2002.
\bibitem{treewidth}N.Robertson,P.D.Seymour,\emph{Graph minors II,Algorithmic aspects of treewidth}, J.Algorithms 7(1986) 309â€“322.
\end{thebibliography}
\end{document}
