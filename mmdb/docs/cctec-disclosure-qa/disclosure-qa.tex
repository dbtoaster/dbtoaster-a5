\documentclass{article}
\usepackage{fullpage}
\usepackage{url}
\newcommand{\compiler}{DBToaster}
\begin{document}
\title{\compiler\ Provisional Patent Application Supplementary Notes}
\author{Yanif Ahmad \hspace{5mm} Christoph Koch\\yna3@cornell.edu\ \ koch@cs.cornell.edu}
\date{}
\maketitle

\vspace{-4mm}
\noindent This document details patent-specific issues, beyond the technical description of the 
invention found in \cite{dbtoaster-draft}.

\section{Invention Background}
We consider this invention as solving the problem of processing standing queries over a rapidly, and \textit{arbitrarily} changing database, using incremental processing techniques. With this in mind, our invention is related to both data stream processing, and incremental view maintenance. Data stream processing addresses the problem of processing standing queries over a limited form of database, namely sliding windows on sequential data. A window restricts the set of data to be processed to a very specific subset, typically a recent period of time.
Incremental view maintenance on the other hand considers queries on a general database, that can be modified in any manner, and does not need to consist of only recent data. However the limitations of view maintenance lies in the class of queries supported, especially in terms of nested aggregates, and subqueries, and have been shown to have problems scaling to handle large volumes of changing data. Thus neither of these solutions are sufficient for the applications we discuss later in this document.
\begin{itemize}
\item We refer the reader to \cite{dbtoaster-draft}, Section 1, 5  for more details on the contributions of \compiler\ over existing database technologies.
\end{itemize}

We now list several vendors of both stream processing engines and relational databases supporting incremental view maintenance, reiterating that these systems are highly inefficient for dealing with the applications we have in mind:

\begin{itemize}

\item StreamBase~\cite{streambase}: provide two primary components in their stream processing product, a development environment for authoring stream processing applications (StreamBase Studio) and a server (StreamBase Server) performing the actual computation. To date, StreamBase are the only known vendor to have filed a patent application~\cite{sb-patent} that shares the same broad goal of compilation, but uses an incomparable and limited algorithm, from which our approach differs greatly, resulting in our technological advantage.
\item Coral8~\cite{coral8}: follows a similar product offering to StreamBase with their development environment and backend server.
\item Progress Apama~\cite{apama}, Truviso~\cite{truviso}: have not directly tested product, assume similar to above.
\item IBM Infosphere Streams~\cite{ibm}: no product released yet, visual IDE and backend engine expected to be released in 2010.
\item Microsoft~\cite{ms}: recently announced intention to enter market, assumed to be released as part of SQL Server 2008 R2.
\end{itemize}

\section{Invention Contributions and Patentable Scope}
\compiler\ consists of one primary claim, namely our aggressive compilation algorithm for 
transforming SQL queries to low-level code, which to the best of our knowledge meets all three 
major requirements of a patent in  being 1) novel, 2) non-obvious and 3) useful (as we outline in 
Section~\ref{sec:uses} of this  document).
We briefly describe aggressive compilation here.

Aggressive compilation refers to our recursive compilation of queries into code. Traditional view 
maintenance algorithms typically consider a type of modification (insert, update, or delete) to a 
view, and derive a query to process this modification. Thus existing algorithms produce a view 
maintenance \textit{query}, that is often simpler than the original query defining the view. However, 
this is only a single level of incremental computation, and the job of view maintenance overall still
relies  on queries. Our approach is to \textit{recursively} apply compilation on these resulting 
queries, until we eliminate all queries, leaving simple and highly efficient low-level code. 
Aggressive compilation distinguishes our invention from the related technologies, to the best of our 
knowledge, as follows:
 
\begin{itemize}
\item Aggressive inlining and rule-based transformation of a SQL query plan produces event-
handling functions, capable of processing queries and producing results. We produce one of these 
event  handling functions for each type of modification event (insert, update, or delete) on any input 
relation to the query. 
\item Our transformation replaces query plans (i.e. graphs) found in both traditional relational 
databases and existing stream processing engines, with these event handling functions. Query 
graphs typically include dataflow between \textit{operators}, which in turn hold queues and data 
structures as state to support their computation. Our compiler transforms and inlines these 
operators in a non-trivial manner, completely eliminating queues, and making global decisions on 
what data structures to maintain to support the query, \textit{in its entirety, and in particular for each 
type of modification event}, rather than at the individual operator level. We also support reusing 
data structures chosen across different modification events, whereby such sharing reduces 
memory consumed.
\item  We refer the reader to \cite{dbtoaster-draft}, Section 1, Example 1.1, and Section 3 for more details.
\end{itemize}

\section{Making the Invention}
While the core patentable aspect of our work is that of the compilation algorithm, we briefly 
describe how we would realise this invention as a product. We envision a package 
consisting of several software components, first and foremost the \compiler\ compiler, which is 
responsible for producing source code or object code, that may be edited or simply linked in with 
existing client application code. We refer to this usage model of \compiler\ as generating an 
\textit{embeddable} query processor. Our generated code will also expose a wide API that allows 
direct (read-only) access to internal data structures for reuse in answering further queries on the 
client side. We also envision a full suite of development tools encompassing our compiler, including 
front-end components such as a query development environment, build tools, to ease integrating 
query compilation into existing build workflows (such as those produced via Eclipse and Microsoft 
Visual Studio),  a debugger, to support testing and tracing query processing events, and finally a profiler to report and visualize query processing performance.
% Finally we see the potential for a \textit{hosted} compilation and potentially execution model, 
% whereby compilation is provided as a hosted service for users entering their queries through a web 
% browser.
\begin{itemize}
\item We refer the reader to Section 2 in \cite{dbtoaster-draft} for further details on \compiler\ 
usage.
\end{itemize}

%\section{Possible Alternate Versions}

\section{Probable Uses}
\label{sec:uses}
We see the following use cases. Note that this is not a complete list by any means, but simply
represents the applications where we have greatest familiarity, thus are confident about the
potential of this invention.

\begin{itemize}
\item Financial applications: \compiler\ can be used to develop automated trading algorithms (a.k.a 
algos, such as "following the ax" or "iceberging"), both reducing the development time through the 
use of a declarative language such as SQL, and also providing orders of magnitude better 
performance in terms of both throughput and latency for queries over level II (i.e. orderbook) data. 
Note in our preliminary experiments, the commercial stream processing engines cannot handle 
queries over orderbook data efficiently, due to the arbitrary pattern of changes to the orderbook. Furthermore, we foresee a straightforward extension of \compiler\  to handle window queries as often seen in prototypical use cases of commercial SPEs for technical and fundamental analysis in algos. Producing a complete software suite for financial applications will also require developing backtesting tools as part of our debugger, and a visualization frontend capable of interactive charting. We are confident our invention provides a significant technical advantage over the stream processing engines targeting algorithmic trading applications.

\item Monitoring applications: the standing queries supported by \compiler\ and stream processing engines have brought an abundance of \textit{monitoring} applications into focus. Monitoring applications continuously check for the occurrence of events through a \textit{sensing} infrastructure and subsequently execute application logic to determine how to \textit{respond} or \textit{act} to the event. This general application model covers numerous examples including infrastructure monitoring (e.g., industrial plant, road network and traffic, data and telephony network monitoring), environmental monitoring (e.g. carbon emission monitoring, energy consumption and utilization in datacenters),  as well as social network monitoring applications and geolocation-driven services.
In addition to providing an appropriate query processing framework for these applications, \compiler\ could enable uniformly using the core of a high-level declarative language, SQL, across the multiple heterogeneous computing platforms present in such applications, by transforming to low-level code and customizing such code to execute on embedded devices such sensor motes, and cell phones.

\item Database applications: since the underlying data model of \compiler\ is that of a database 
instance subject to arbitrary changes, in the long run, we see \compiler\ naturally being extended to 
support more of the functionality found in full fledged relational databases such as Oracle, DB2, SQL Server, including analysis queries as found in business intelligence, operational logistics, and more generally, online analytical processing (OLAP) applications. Moreover, we expect to see substantial performance gains over these systems, as we have seen with both the VWAP and SSB queries in the experiments conducted in \cite{dbtoaster-draft}.
\end{itemize}

\begin{thebibliography}{1}
\bibitem{dbtoaster-draft} Y. Ahmad, C. Koch. DBToaster: Compiling main-memory database query 
processors. Working draft. June 2009.
\bibitem{xbow} Crossbow Technology. \url{http://www.xbow.com}
\bibitem{streambase} StreamBase Systems. \url{http://www.streambase.com}
\bibitem{sb-patent}
J. Salz, R. Tibbetts,
{Stream processor with compiled programs.\\
{U.S. Patent Application}, {app. \#11/644,189, pub. \#US 2008/0134158 A1}},
{Dec 22, 2006}
\bibitem{coral8} Coral8/Aleri. \url{http://www.coral8.com}, \url{http://www.aleri.com/}
\bibitem{apama} Progress Apama. \url{http://www.progress.com/apama}
\bibitem{truviso} Truviso. \url{http://www.truviso.com}
\bibitem{kx} Kx Systems. \url{http://www.kx.com}
\bibitem{ibm} IBM Infosphere Streams (formerly IBM Research's System S).\\
\url{http://www-01.ibm.com/software/data/infosphere/streams/}
\bibitem{ms} Microsoft Corporation.
Introducing Microsoft’s Platform for Complex Event Processing\\
\url{http://download.microsoft.com/download/F/D/5/FD5E855C-D895-45A8-9F3E-110AFADBE51A/Microsoft\%20CEP\%20Overview.docx}
\end{thebibliography}

\end{document}